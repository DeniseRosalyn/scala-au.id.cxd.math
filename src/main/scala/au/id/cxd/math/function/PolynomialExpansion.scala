package au.id.cxd.math.function

import au.id.cxd.math.count.{Choose, Permutation}
import breeze.linalg.DenseMatrix

/**
  * Expand a supplied matrix as series of polynomial factors.
  *
  *
  * This procedure can be used to generate features
  * for an input vector X.
  *
  * For example if X has 2 columns and we seek a degree n = 2 polynomial
  * (a, b) will have (a, b, a&#94;2, 2ab, b&#94;2)  which is 3 extra features
  *
  * $$
  * (a, b, c)^n = (a, b, b, a&#94;2, ab, b&#94;2, bc, c&#94;2, x&#94;3, x&#94;2b, x&#94;2c, ab&#94;2, abc, ac&#94;2, b&#94;3, c&#94;3, ..., )
  * $$
  *
  * We can use the multinomial theorem to do the expansion of the sum
  *
  * $$
  * (x_1 + x_2 + \cdots + x_m)&#94;2 = \sum_{k_1+k_2+\cdots k_m = n}\left( n \choose {k_1, k_2, \cdots , \k_m \right \prod_{1\leqt\leqm} x_t&#94;{k_t}
  * $$
  *
  * the coefficients up to n can be determined using the rule
  *
  * $$
  * \left( n \choose {k_1, k_2, k_3, ..., k_m} \right)
  * $$
  *
  * where for any combination of $k$ $\sum_{i=1}&#94;m k$ must equal $n$.
  *
  * $m$ represents the number of columns in matrix $X$ and has
  *
  * the number of combinations of coefficients would be ${n + m - 1} \choose {m - 1}$.
  *
  * The theorem is described here:
  *
  * https://en.wikipedia.org/wiki/Multinomial_theorem
  *
  * @param X      - the matrix to transform
  * @param degree the degree of the polynomial
  *
  *
  *               Created by cd on 23/04/2016.
  */
class PolynomialExpansion(val X: DenseMatrix[Double], val degree: Int) {


  /**
    * determine how many coefficients there will be in total
    *
    * @return
    */
  def count(): Int = {
    val a = X.cols + degree - 1
    val b = degree - 1
    val total = Choose(a)(b)
    total toInt
  }

  /**
    * determine the number of permutations possible for the columns in X choosing degree of polynomial.
    *
    * I $X$ has $k$ columns the number of permutations of powers will be: $P_k&#94;k$
    *
    * @return
    */
  def permutations(): Int = Permutation(X.cols)(X.cols) toInt


  /**
    * transform X into the polynomial of supplied degree
    *
    * the rows represent the set of coefficients
    * the columns represent the powers of each column of X
    * for each row of X, iterate the rows of the powers,
    * each new column is generated by the product of the columns of X raised to the columns in powers(row, ::)
    *
    * The resulting matrix has dimensions rows of X and columns cols X + cols X + degree -1 choose degree - 1
    */
  def transform() = {
    val powers = generatePowers()
    // the rows represent the set of coefficients
    // the columns represent the powers of each column of X
    // for each row of X, iterate the rows of the powers, each new column is generated by the product of the columns of powers(row, ::)
    val M = DenseMatrix.zeros[Double](X.rows, powers.rows + X.cols)
    M(::,0 until X.cols) := X
    val offset = X.cols
    val M2 = DenseMatrix.tabulate[Double](X.rows, powers.rows) {
      case (i, j) => {
        val row = powers(j, ::) .inner
        val raised = for(k <- 0 to row.length) yield Math.pow(X(i, k), row(k))
        val prod = raised.reduce { (a, b) => a*b }
        prod
      }
    }
    M(::,offset until powers.rows + X.cols) := M2
    M
  }

  /**
    * build a series of powers
    *
    * this is a permutation of series that sum to n
    *
    * for example for n = 3 and m = 3 we expect 10 coefficients where the value is
    *
    * $3 = 3 + 0$ or $3 = 2 + 1 + 0 or 3 = 1+1+1$
    *
    * 3+0
    * (3,0,0)
    * (0,3,0)
    * (0,0,3)
    *
    * 2+1
    * (2,1,0)
    * (2,0,1)
    * (1,2,0)
    * (1,0,2)
    * (0,2,1)
    * (0,1,2)
    *
    * and the series:
    * (1,1,1)
    *
    * Yielding the vector $(a, b, c, a&#94;3, b&#94;3, c&#94;3, a&#94;2b, a&#94;2c, ab&#94;2, ac&#94;2, b&#94;2c, bc&#94;2)$
    *
    * This is a combinatorial problem, where we first need to determine the number of sets of summations to $n$
    *
    * $$
    * n = \left{ (a_1, b_1, ..., p_2), (a_2, b_2, ..., p_2), ..., (a_k, b_k, ..., p_k) \right}
    * $$
    * Then the number of permutations of those summations which will be $P_p&#94;p$ permutations for each set.
    *
    * @return
    */
  def generatePowers() = {
    // compute the set of vlaues that sum to n other than n + 0 and 1's
    // include degree n in the sequence.
    val sequence = for (i <- 0 to degree) yield i
    // pad the sequence that is generated to the same number of columns as X
    val seed = pad(X.cols)(sumUntil(degree)(sequence))

    // use a diagonal matrix of rank X.cols to generate the powers for set1
    // this is essentially a diagonal matrix where the value is the degree of the polynomial
    val mat1 = DenseMatrix.tabulate[Double](X.cols, X.cols) {
      case (i, j) => i == j match {
        case true => degree
        case _ => 0.0
      }
    }

    val rows = permutations
    // the permutations of powers in a table that is number of permutations x X.cols
    val mat2 = generateTrie(DenseMatrix.zeros(permutations, X.cols))(seed, 0, (0, 0))

    val set2 = for (i <- 0 until X.cols) yield 1
    // we have the two special cases of set1 and set2
    // now we need to generate the permutations of the original padded set.

    val powers = DenseMatrix.zeros(mat1.rows + mat2.rows + 1, X.cols)
    powers(0 until mat1.rows, ::) := mat1
    powers(mat1.rows until mat1.rows + mat2.rows, ::) := mat2
    powers(powers.rows - 1, ::) := set2

    powers
  }

  /**
    * note generating the powers can be achieved as an m-way tree where the root is m-way and each path is (n - depth)-way subtree
    * this is a series of expansions down each path were each subtree is the subset of the prior path
    *
    * generate the trie where the matrix M is of rows $P_k&#94;k and cols X.cols
    * the coordinates represent the level of the traversal (or row) and the column (or position in the seed vector)
    *
    * @param M
    * @param seed
    * @param level
    * @param parent
    * @return
    */
  def generateTrie(M: DenseMatrix[Double])(seed: Seq[Int], level: Int, parent: (Int, Int)): DenseMatrix[Double] = {
    level == 0 match {
      case true => seed.foldLeft(M) { (accum, j) => {
        accum(level, j) = j
        generateTrie(accum)(seed, level + 1, (level, j))
      }
      }
      case false => {
        val subseq = seed filterNot { k => k == parent._2 }
        subseq.foldLeft(M) {
          (accum, j) => {
            accum(level, j) = j
            generateTrie(accum)(subseq, level + 1, (level, j))
          }
        }
      }
    }
  }

  /**
    * Collate the set of values in sequence k until they summate to n
    *
    * @param n
    * @param seq
    * @return
    */
  def sumUntil(n: Int)(seq: Seq[Int]) =
    seq.foldLeft((0, List[Int]())) {
      (accum, k) => {
        val total = accum._1
        val set = accum._2
        accum == n match {
          case true => (n, set)
          case false => (total + k, set :+ k)
        }
      }
    }._2

  /**
    * pad a sequence with zeroes until it is length n
    *
    * @param n
    * @param seq
    * @return
    */
  def pad(n: Int)(seq: Seq[Int]) =
    for (i <- 0 until n) yield i < seq.length match {
      case true => seq(i)
      case _ => 0
    }

}

object PolynomialExpansion {
  /**
    * transform X into the n degree polynomial.
    * @param X
    * @param degree
    * @return
    */
  def apply(X: DenseMatrix[Double], degree: Int) = new PolynomialExpansion(X, degree) transform
}
